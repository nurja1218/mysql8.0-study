## 세미 조인

### 세미 조인

- 다른 테이블에 조건에 일치하는 레코드 존재 유무만 체크하는 형태
  ```sql
  SELECT *
  FROM employees e
  WHERE e.emp_no IN
  	(SELECT de.emp_no FROM dept_emp de WHERE de.from_date='1996-03-09'));  // 세미 조인
  ```
- MySQL 버전에 따른 차이점
  - MySQL 5.7
    - 서브 쿼리가 먼저 실행된 후 일치하는 레코드만 검색할 것으로 예상했으나..!
    - 메인 테이블을 풀 스캔하면서 각각의 레코드가 서브 쿼리 조건에 일치하는지 비교한다.
  - MySQL 8.0
    - 세미 조인 최적화가 가능해졌다.
    - 다양한 최적화 전략들
        <aside>
        💡 최적화 전략은 옵티마이저가 선택한다. 우리는 사용 여부만 설정할 수 있다.
        
        </aside>
        
        - `Table Pull-out` → 성능 Good!
        - `Duplicate Weed-out` → 옵티마이저 스위치로 사용 여부 설정 가능
        - `First Match` → 옵티마이저 옵션으로 사용 여부 설정 가능
        - `Loose Scan` → 옵티마이저의 사용 여부 설정 가능
        - `Materialization` → 옵티마이저 스위치로 사용 여부 설정 가능
- 세미 조인의 형태
    <aside>
    💡 이 부분은 제가 충분하게 조사를 못한 것 같아서 다음주에 추가적인 내용 전달드리도록 하겠습니다🙇‍♀️
    
    </aside>
    
    - = or IN()
        - 세미 조인 최적화
        - IN-to-EXISTS 최적화
        - MATERIALIZATION 최적화
    - <> or NOT IN()
        - IN-to-EXISTS 최적화
        - MATERIALIZATION 최적화

### Table Pull-out 최적화

- 서브 쿼리에서 사용된 테이블을 아우터 쿼리로 끄집어 낸 후 쿼리를 JOIN 쿼리로 재작성하는 최적화 방법
- explain 시 Table Pull-out은 사용되었다는 문구가 출력되지 않기 때문에 실행계획에서 id 칼럼 값이 동일한지 비교해봐야한다.
  - id 값이 동일하다는 건, 서브 쿼리 패턴으로 실행되지 않고 JOIN으로 처리되었다는 뜻!
- 더 정확한 확인을 위해서는 explain 명령 수행 직후 SHOW WARNINGS 명령으로 MySQL 옵티마이저가 재작성한 쿼리를 살펴본다.
  ```sql
  SHOW WARNINGS \G
  ```
- 단, 모든 쿼리에서 사용될 수 있는 최적화 방법은 아니다.
  - 세미 조인 `서브쿼리에서만 사용 가능`하다.
  - 유니크 인덱스나 프라이머리 키로 인해 `결과가 1건인 경우에만 사용 가능`하다.
  - Table Pull-out 방식이 적용되더라도 기존 쿼리의 최적화 방법이 사용 불가한 것은 아니기 때문에 최대한 Table Pull-out을 적용한다.
  - 서브 쿼리에서 사용된 테이블을 아우터 쿼리로 가져와 조인하는데, 서브 쿼리 모든 테이블이 아우터 쿼리로 변경 가능한 경우 서브 쿼리 자체는 없어진다.
  - “최대한 서브 쿼리를 조인으로 풀어 사용하라”는 튜닝 가이드가 많은데 작업자는 이제 굳이 서브 쿼리를 조인으로 풀 필요가 없다.

### First Match

- IN() 형태의 세미 조인을 EXISTS() 형태로 튜닝하는 것과 비슷한 최적화 방법
- explain 시 Table Pull-out 과 마찬가지로 id 칼럼 값이 모두 동일하고 Table Pull-out 과 다르게 “FirstMatch(e)”라는 문구가 출력된다.
- First Match는 일치하는 레코드 1건만 찾으면 더이상 테이블 검색을 진행하지 않는다. 따라서 의미상 EXISTS()와 동일하게 처리된 것이다.
- MySQL 5.5의 IN-to-EXISTS에 비해 장점
  - 여러 테이블이 조인되는 경우 가끔 옵티마이저가 쿼리에 없는 동등 조건을 자동으로 추가하는데 IN-to-EXISTS에서는 서브 쿼리 내에서만 가능했지만 FirstMatch에서는 조인 형태로 처리되어 아우터 쿼리 테이블까지 전파될 수 있다. 이전보다 더 많은 조건이 주어지는 것이다보니 더 나은 실행 계획을 만든다.
  - IN-to-EXISTS에서는 어떠한 조건없이 변환 가능한 경우 무조건 최적화를 수행했지만 FistMatch에서는 서브 쿼리의 모든 테이블에 대해 최적화를 수행할지 아니면 일부 테이블에서만 수행할 지 선택할 수 있다.
- FirstMatch 제한 사항 및 특성
  - 하나의 레코드만 검색되면 검색을 멈추는 단축 실행 경로이다보니 서브 쿼리가 참조하는 모든 아우터 테이블이 조회된 이후에 실행된다.
  - 실행 계획의 Extra 칼럼에 FirstMatch(table-N) 문구가 출력된다.
  - 상관 서브쿼리에서도 사용될 수 있다.
  - GROUP BY나 집합 함수가 사용된 서브 쿼리에서는 사용될 수 없다.

### Loose Scan

- 테이블의 프라이머리 키를 루스 인덱스 스캔으로 유니크한 값만 읽어 효율적으로 서브 쿼리를 실행한다.(중복 레코드도 제거됨)
- 서브 쿼리의 테이블이 드라이빙 테이블이 된다.
- explain 시 LooseScan 이라는 문구가 출력되고 id 값도 1의 값으로 동일하기 때문에 내부적으로는 조인처럼 처리됐다고 볼 수 있다.
- 특성
  - 루스 인덱스 스캔으로 서브 쿼리 테이블을 먼저 읽고 아우터 테이블을 드리븐으로 사용하여 조인을 수행한다. 따라서 서브 쿼리가 루스 인덱스 스캔을 활용할 수 있는 조건이 갖추어져야한다.
- LooseScan 최적화 비활성화하기
  ```sql
  SET optimizer_switch='loosescan=off';
  ```
