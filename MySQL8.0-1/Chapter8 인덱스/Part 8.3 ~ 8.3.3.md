- B-Tree 인덱스
  - 컬럼의 원래 값을 변형하지 않고 인덱스 구조체 내에서 항상 정렬된 상태로 유지
  - 가장 일반적으로 사용되고 가장 먼저 도입됨
  - B → Balanced
  https://steady-coding.tistory.com/558
- 구조 및 특성
  - 루트(최상위), 브랜치(중간 노드), 리프노드(실제 주소값을 가진 최하위)로 구성
  - InnoDB - 세컨더리 키 인덱스 트리 탐색 → 프라이머리 키 인덱스 트리 탐색 → 리프노드 데이터 읽기
  - myISAM vs InnoDB
    - MyISAM - 세컨더리 인덱스가 물리적인 주소를 갖음
    - InnoDB - 데이터 주소 대신 PK주소 사용
- 인덱스 키 추가 및 삭제
  - 인덱스 키 추가
    - 저장될 위치 탐색 → 리프노드에 저장
    - 리프노드가 가득 차면 노드를 분리 - 상위 노드까지 처리범위가 확대되어 쓰기 비용이 많이 든다
  - 인덱스 키 삭제
    - 해당 키값이 저장된 리프 노드를 찾아 삭제 마킹
    - 마킹작업도 I/O작업이 필요, 버퍼링 지연 처리 가능
  - 인덱스 키 변경
    - 단순 변경은 불가능 (값에 따라 리프노드의 위치가 결정)
    - 삭제 후 추가되는 형식
  - 인덱스 키 검색
    - 트리 탐색을 사용하여 조회(select뿐아니라 update delete처리를 위해 검색할때도 사용)
    - 100% 일치(동등 연산, = ‘test') 또는 값의 앞부분만 일치하는 경우(LIKE 연산, “test%”) 사용 가능
    - 부등호 (< , >) 비교 조건에서 사용 가능
    - 키 값의 뒷부분만 검색하는 경우(LIKE 연산, “%test”) 사용 불가능
    - 키 값에 변형이 가해지는 경우 사용 불가능
    - 넥스트키락(갭락)등을 이용하는 InnoDB는 인덱스 설정이 제대로 이뤄지지 않으면 불필요하게 많은 레코드를 잠글 수 있다.
- B-Tree 인덱스 사용에 영향을 미치는 요소
  - 인덱스 키 값의 크기
    - B-Tree의 자식 노드 개수는 인덱스 페이지 크기와 키 값의 크기에 따라 결정
    - 기본 16kb, 4~64까지 설정 가능
    - 인덱스키값 = 12byte
    - 쿼리가 한번에 500개 읽어야 할 때 최대 자식노드 수가 500보다 작으면 2번이상 읽어야 한다.
    - 인덱스의 크기가 커지면 한 페이지에 저장할 수 있는 개수가 줄고 더 많은 메모리를 소요해야하므로 가능한 작게 설정하는게 좋음
  - B-Tree 깊이
    - 깊이는 직접 조절할 수 없다
    - 깊이는 값을 검색할 때 몇 번이나 디스크를 읽어야 하는지와 직결
    - 인덱스 키 값의 크기가 커질수록 인덱스 키 값의 개수가 적어지고 B-Tree의 깊이도 깊어진다
  - 선택도(기수성)
    - 모든 인덱스 키 값 가운데 유니크한 값의 수
    - 인덱스 키 값 중 중복된 값이 많아지면 기수성은 낮아지고, 선택도도 떨어진다.
    - 선택도가 높을수록 검색 대상이 줄어 빠르게 처리됨
    - 유니크한 값의 개수는 효율성에 큰 영향을 미친다.
